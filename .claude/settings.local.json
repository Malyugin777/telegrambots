{
  "permissions": {
    "allow": [
      "Bash(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@66.151.33.167 \"echo ''Connected successfully'' && mkdir -p /root/nexus_project && ls -la /root/\")",
      "Bash(pip install:*)",
      "Bash(python -m pip install:*)",
      "Bash(python3 -m pip install:*)",
      "Bash(powershell -Command \"python --version\")",
      "Bash(powershell -Command:*)",
      "Bash(git init:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(gh auth status:*)",
      "Bash(git remote add:*)",
      "Bash(git branch:*)",
      "Bash(git push:*)",
      "Bash(powershell:*)",
      "Bash(ssh root@66.151.33.167 \"cd /root/nexus_project && git pull origin main\")",
      "Bash(ssh root@66.151.33.167 \"cd /root/nexus_project/infrastructure && cp -n .env.example .env && docker-compose up -d --build\")",
      "Bash(ssh root@66.151.33.167 \"cd /root/nexus_project/infrastructure && cp -n .env.example .env && docker compose up -d --build\")",
      "Bash(ssh root@66.151.33.167 \"cd /root/nexus_project && git pull origin main && cd infrastructure && docker compose up -d --build\")",
      "Bash(ssh root@66.151.33.167 \"cd /root/nexus_project && git pull && cd infrastructure && docker compose up -d --build\")",
      "Bash(ssh root@66.151.33.167 \"docker ps && echo ''---'' && curl -s -o /dev/null -w ''%{http_code}'' http://localhost:80\")",
      "Bash(ssh root@66.151.33.167 \"curl -s http://localhost/ | head -20\")",
      "Bash(ssh root@66.151.33.167:*)",
      "Bash(git check-ignore:*)",
      "Bash(cat:*)",
      "Bash(python3 -c \"\nimport os\ncontent = ''''''\"\"\"\"\"\"\n–°–µ—Ä–≤–∏—Å —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ yt-dlp\n\n–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã:\n- TikTok (vm.tiktok.com, tiktok.com) ‚Äî –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞\n- Instagram Reels (instagram.com/reel/, instagram.com/p/)\n- YouTube Shorts (youtube.com/shorts/)\n- Pinterest (pin.it, pinterest.com)\n\"\"\"\"\"\"\nimport os\nimport asyncio\nimport logging\nimport uuid\nimport shutil\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List\nfrom concurrent.futures import ThreadPoolExecutor\n\nimport yt_dlp\n\nfrom ..config import config\n\nlogger = logging.getLogger(__name__)\n\n# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã\nDOWNLOAD_DIR = \"\"/tmp/downloads\"\"\nMAX_FILE_SIZE_MB = 50\nMAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024\nDOWNLOAD_TIMEOUT = 60  # —Å–µ–∫—É–Ω–¥\nAUDIO_BITRATE = \"\"320\"\"  # kbps\n\n# –ü—É–ª –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π yt-dlp\n_executor = ThreadPoolExecutor(max_workers=5)\n\n\ndef _is_instagram_url(url: str) -> bool:\n    \"\"\"\"\"\"–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ URL —Å—Å—ã–ª–∫–æ–π –Ω–∞ Instagram\"\"\"\"\"\"\n    return \"\"instagram.com\"\" in url.lower()\n\n\n@dataclass\nclass MediaInfo:\n    \"\"\"\"\"\"–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–µ–¥–∏–∞—Ñ–∞–π–ª–µ\"\"\"\"\"\"\n    title: str = \"\"video\"\"\n    author: str = \"\"unknown\"\"\n    duration: int = 0\n    thumbnail: Optional[str] = None\n    platform: str = \"\"unknown\"\"\n\n\n@dataclass\nclass DownloadResult:\n    \"\"\"\"\"\"–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–∞—á–∏–≤–∞–Ω–∏—è\"\"\"\"\"\"\n    success: bool\n    file_path: Optional[str] = None\n    filename: Optional[str] = None\n    info: MediaInfo = field(default_factory=MediaInfo)\n    file_size: int = 0\n    error: Optional[str] = None\n    is_instagram_error: bool = False\n\n\nclass VideoDownloader:\n    \"\"\"\"\"\"\n    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∑–∞–≥—Ä—É–∑—á–∏–∫ –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ yt-dlp\n\n    –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\n        downloader = VideoDownloader()\n        result = await downloader.download(url)\n        if result.success:\n            await bot.send_video(chat_id, result.file_path)\n            await downloader.cleanup(result.file_path)\n    \"\"\"\"\"\"\n\n    def __init__(self):\n        \"\"\"\"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑—á–∏–∫–∞\"\"\"\"\"\"\n        os.makedirs(DOWNLOAD_DIR, exist_ok=True)\n\n    def _get_video_options(self, output_path: str, url: str = \"\"\"\") -> dict:\n        \"\"\"\"\"\"\n        –û–ø—Ü–∏–∏ yt-dlp –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ\n\n        Args:\n            output_path: –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞\n            url: URL –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã\n        \"\"\"\"\"\"\n        opts = {\n            \"\"quiet\"\": True,\n            \"\"no_warnings\"\": True,\n            \"\"noprogress\"\": True,\n            \"\"format\"\": (\n                \"\"best[ext=mp4][filesize<50M]/\"\"\n                \"\"best[filesize<50M]/\"\"\n                \"\"bestvideo[ext=mp4]+bestaudio[ext=m4a]/\"\"\n                \"\"bestvideo+bestaudio/best\"\"\n            ),\n            \"\"merge_output_format\"\": \"\"mp4\"\",\n            \"\"outtmpl\"\": output_path,\n            \"\"socket_timeout\"\": 30,\n            \"\"retries\"\": 3,\n            \"\"fragment_retries\"\": 3,\n            \"\"nocheckcertificate\"\": True,\n            \"\"geo_bypass\"\": True,\n            \"\"postprocessor_args\"\": {\n                \"\"ffmpeg\"\": [\"\"-c\"\", \"\"copy\"\"]\n            },\n            \"\"extractor_args\"\": {\n                \"\"tiktok\"\": {\n                    \"\"api_hostname\"\": \"\"api22-normal-c-useast2a.tiktokv.com\"\",\n                    \"\"webpage_download\"\": True,\n                }\n            },\n            \"\"http_headers\"\": {\n                \"\"User-Agent\"\": (\n                    \"\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\"\n                    \"\"AppleWebKit/537.36 (KHTML, like Gecko) \"\"\n                    \"\"Chrome/120.0.0.0 Safari/537.36\"\"\n                ),\n            },\n        }\n\n        if _is_instagram_url(url) and config.instagram_cookies_file:\n            cookies_path = config.instagram_cookies_file\n            if os.path.exists(cookies_path):\n                opts[\"\"cookiefile\"\"] = cookies_path\n                logger.info(f\"\"Using Instagram cookies from {cookies_path}\"\")\n\n        return opts\n\n    def _get_audio_options(self, output_path: str, url: str = \"\"\"\") -> dict:\n        opts = {\n            \"\"quiet\"\": True,\n            \"\"no_warnings\"\": True,\n            \"\"noprogress\"\": True,\n            \"\"format\"\": \"\"bestaudio/best\"\",\n            \"\"outtmpl\"\": output_path,\n            \"\"postprocessors\"\": [{\n                \"\"key\"\": \"\"FFmpegExtractAudio\"\",\n                \"\"preferredcodec\"\": \"\"mp3\"\",\n                \"\"preferredquality\"\": AUDIO_BITRATE,\n            }],\n            \"\"socket_timeout\"\": 30,\n            \"\"retries\"\": 3,\n            \"\"nocheckcertificate\"\": True,\n            \"\"geo_bypass\"\": True,\n            \"\"extractor_args\"\": {\n                \"\"tiktok\"\": {\n                    \"\"api_hostname\"\": \"\"api22-normal-c-useast2a.tiktokv.com\"\",\n                }\n            },\n        }\n\n        if _is_instagram_url(url) and config.instagram_cookies_file:\n            cookies_path = config.instagram_cookies_file\n            if os.path.exists(cookies_path):\n                opts[\"\"cookiefile\"\"] = cookies_path\n\n        return opts\n\n    def _get_info_options(self) -> dict:\n        return {\n            \"\"quiet\"\": True,\n            \"\"no_warnings\"\": True,\n            \"\"extract_flat\"\": False,\n            \"\"skip_download\"\": True,\n            \"\"socket_timeout\"\": 15,\n            \"\"nocheckcertificate\"\": True,\n        }\n\n    def _generate_filepath(self, ext: str = \"\"mp4\"\") -> str:\n        unique_id = str(uuid.uuid4())[:12]\n        return os.path.join(DOWNLOAD_DIR, f\"\"{unique_id}.{ext}\"\")\n\n    def _extract_info(self, info: dict) -> MediaInfo:\n        title = info.get(\"\"title\"\", \"\"video\"\")\n        if isinstance(title, str):\n            title = title[:100]\n        else:\n            title = \"\"video\"\"\n\n        author = info.get(\"\"uploader\"\") or info.get(\"\"channel\"\") or info.get(\"\"creator\"\") or \"\"unknown\"\"\n        if not isinstance(author, str):\n            author = \"\"unknown\"\"\n\n        return MediaInfo(\n            title=title,\n            author=author,\n            duration=int(info.get(\"\"duration\"\", 0) or 0),\n            thumbnail=info.get(\"\"thumbnail\"\"),\n            platform=info.get(\"\"extractor\"\", \"\"unknown\"\"),\n        )\n\n    def _sanitize_filename(self, title: str, ext: str) -> str:\n        if not isinstance(title, str):\n            title = \"\"video\"\"\n        safe = \"\"\"\".join(c for c in title if c.isalnum() or c in \"\" -_\"\").strip()\n        safe = safe[:50] if safe else \"\"video\"\"\n        return f\"\"{safe}.{ext}\"\"\n\n    async def download(self, url: str) -> DownloadResult:\n        output_path = self._generate_filepath(\"\"mp4\"\")\n        opts = self._get_video_options(output_path, url)\n        is_instagram = _is_instagram_url(url)\n\n        try:\n            loop = asyncio.get_running_loop()\n            result = await asyncio.wait_for(\n                loop.run_in_executor(_executor, self._download_sync, url, opts, False, is_instagram),\n                timeout=DOWNLOAD_TIMEOUT\n            )\n\n            if not result.success:\n                return result\n\n            if result.file_size > MAX_FILE_SIZE_BYTES:\n                await self.cleanup(result.file_path)\n                return DownloadResult(\n                    success=False,\n                    error=f\"\"–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({result.file_size // 1024 // 1024}MB > {MAX_FILE_SIZE_MB}MB)\"\"\n                )\n\n            return result\n\n        except asyncio.TimeoutError:\n            await self.cleanup(output_path)\n            return DownloadResult(success=False, error=f\"\"–¢–∞–π–º–∞—É—Ç –∑–∞–≥—Ä—É–∑–∫–∏ ({DOWNLOAD_TIMEOUT} —Å–µ–∫)\"\")\n        except Exception as e:\n            logger.exception(f\"\"Download error for {url}: {e}\"\")\n            await self.cleanup(output_path)\n            return DownloadResult(success=False, error=self._format_error(str(e), is_instagram), is_instagram_error=is_instagram)\n\n    async def download_audio(self, url: str) -> DownloadResult:\n        base_path = self._generate_filepath(\"\"temp\"\")\n        output_template = base_path.rsplit(\"\".\"\", 1)[0]\n        opts = self._get_audio_options(output_template, url)\n        is_instagram = _is_instagram_url(url)\n\n        try:\n            loop = asyncio.get_running_loop()\n            result = await asyncio.wait_for(\n                loop.run_in_executor(_executor, self._download_sync, url, opts, True, is_instagram),\n                timeout=DOWNLOAD_TIMEOUT\n            )\n\n            if not result.success:\n                return result\n\n            if result.file_size > MAX_FILE_SIZE_BYTES:\n                await self.cleanup(result.file_path)\n                return DownloadResult(success=False, error=f\"\"–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({result.file_size // 1024 // 1024}MB)\"\")\n\n            return result\n\n        except asyncio.TimeoutError:\n            await self.cleanup(f\"\"{output_template}.mp3\"\")\n            return DownloadResult(success=False, error=f\"\"–¢–∞–π–º–∞—É—Ç –∑–∞–≥—Ä—É–∑–∫–∏ ({DOWNLOAD_TIMEOUT} —Å–µ–∫)\"\")\n        except Exception as e:\n            logger.exception(f\"\"Audio download error for {url}: {e}\"\")\n            return DownloadResult(success=False, error=self._format_error(str(e), is_instagram), is_instagram_error=is_instagram)\n\n    async def extract_audio(self, video_path: str) -> DownloadResult:\n        if not os.path.exists(video_path):\n            return DownloadResult(success=False, error=\"\"–í–∏–¥–µ–æ—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω\"\")\n\n        output_path = video_path.rsplit(\"\".\"\", 1)[0] + \"\".mp3\"\"\n\n        try:\n            loop = asyncio.get_running_loop()\n\n            def _extract():\n                import subprocess\n                cmd = [\"\"ffmpeg\"\", \"\"-i\"\", video_path, \"\"-vn\"\", \"\"-acodec\"\", \"\"libmp3lame\"\", \"\"-ab\"\", f\"\"{AUDIO_BITRATE}k\"\", \"\"-ar\"\", \"\"44100\"\", \"\"-y\"\", output_path]\n                result = subprocess.run(cmd, capture_output=True, timeout=60)\n                return result.returncode == 0\n\n            success = await asyncio.wait_for(loop.run_in_executor(_executor, _extract), timeout=DOWNLOAD_TIMEOUT)\n\n            if success and os.path.exists(output_path):\n                file_size = os.path.getsize(output_path)\n                return DownloadResult(success=True, file_path=output_path, filename=\"\"audio.mp3\"\", file_size=file_size)\n            else:\n                return DownloadResult(success=False, error=\"\"–û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∞—É–¥–∏–æ\"\")\n\n        except Exception as e:\n            logger.exception(f\"\"Audio extraction error: {e}\"\")\n            return DownloadResult(success=False, error=str(e)[:100])\n\n    def _download_sync(self, url: str, opts: dict, is_audio: bool = False, is_instagram: bool = False) -> DownloadResult:\n        try:\n            with yt_dlp.YoutubeDL(opts) as ydl:\n                info = ydl.extract_info(url, download=True)\n\n                if not info:\n                    return DownloadResult(success=False, error=\"\"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ\"\", is_instagram_error=is_instagram)\n\n                file_path = self._find_downloaded_file(info, opts, is_audio)\n\n                if not file_path or not os.path.exists(file_path):\n                    return DownloadResult(success=False, error=\"\"–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è\"\", is_instagram_error=is_instagram)\n\n                media_info = self._extract_info(info)\n                file_size = os.path.getsize(file_path)\n                ext = \"\"mp3\"\" if is_audio else \"\"mp4\"\"\n                filename = self._sanitize_filename(media_info.title, ext)\n\n                return DownloadResult(success=True, file_path=file_path, filename=filename, info=media_info, file_size=file_size)\n\n        except yt_dlp.utils.DownloadError as e:\n            error_msg = self._format_error(str(e), is_instagram)\n            return DownloadResult(success=False, error=error_msg, is_instagram_error=is_instagram)\n        except Exception as e:\n            logger.exception(f\"\"yt-dlp sync error: {e}\"\")\n            return DownloadResult(success=False, error=self._format_error(str(e), is_instagram), is_instagram_error=is_instagram)\n\n    def _find_downloaded_file(self, info: dict, opts: dict, is_audio: bool) -> Optional[str]:\n        if \"\"requested_downloads\"\" in info and info[\"\"requested_downloads\"\"]:\n            filepath = info[\"\"requested_downloads\"\"][0].get(\"\"filepath\"\")\n            if filepath and os.path.exists(filepath):\n                return filepath\n\n        template = opts.get(\"\"outtmpl\"\", \"\"\"\")\n        if template:\n            base = template.replace(\"\".%(ext)s\"\", \"\"\"\").replace(\"\"%(ext)s\"\", \"\"\"\")\n            extensions = [\"\"mp3\"\"] if is_audio else [\"\"mp4\"\", \"\"webm\"\", \"\"mkv\"\"]\n            for ext in extensions:\n                path = f\"\"{base}.{ext}\"\"\n                if os.path.exists(path):\n                    return path\n\n        return None\n\n    def _format_error(self, error: str, is_instagram: bool = False) -> str:\n        error_lower = error.lower()\n\n        if is_instagram and (\"\"login\"\" in error_lower or \"\"sign in\"\" in error_lower or\n                            \"\"unavailable\"\" in error_lower or \"\"not available\"\" in error_lower or\n                            \"\"private\"\" in error_lower or \"\"401\"\" in error or \"\"403\"\" in error):\n            return config.messages.get(\"\"instagram_unavailable\"\",\n                \"\"‚ö†Ô∏è Instagram –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π TikTok –∏–ª–∏ YouTube Shorts.\"\")\n\n        if \"\"private\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ\"\"\n        elif \"\"unavailable\"\" in error_lower or \"\"not available\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\"\"\n        elif \"\"age\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É\"\"\n        elif \"\"copyright\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –∏–∑-–∑–∞ –∞–≤—Ç–æ—Ä—Å–∫–∏—Ö –ø—Ä–∞–≤\"\"\n        elif \"\"geo\"\" in error_lower or \"\"country\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –≤ –≤–∞—à–µ–º —Ä–µ–≥–∏–æ–Ω–µ\"\"\n        elif \"\"login\"\" in error_lower or \"\"sign in\"\" in error_lower:\n            return \"\"–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è\"\"\n        elif \"\"404\"\" in error or \"\"not found\"\" in error_lower:\n            return \"\"–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ\"\"\n        elif \"\"rate limit\"\" in error_lower:\n            return \"\"–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ\"\"\n        else:\n            return error[:150] if len(error) > 150 else error\n\n    async def get_info(self, url: str) -> Optional[MediaInfo]:\n        opts = self._get_info_options()\n\n        try:\n            loop = asyncio.get_running_loop()\n\n            def _extract():\n                with yt_dlp.YoutubeDL(opts) as ydl:\n                    return ydl.extract_info(url, download=False)\n\n            info = await asyncio.wait_for(loop.run_in_executor(_executor, _extract), timeout=15)\n\n            if info:\n                return self._extract_info(info)\n            return None\n\n        except Exception as e:\n            logger.warning(f\"\"Failed to get info for {url}: {e}\"\")\n            return None\n\n    async def cleanup(self, *paths: str):\n        for path in paths:\n            if path and os.path.exists(path):\n                try:\n                    os.remove(path)\n                    logger.debug(f\"\"Removed: {path}\"\")\n                except Exception as e:\n                    logger.warning(f\"\"Failed to remove {path}: {e}\"\")\n\n    @staticmethod\n    async def cleanup_old_files(max_age_seconds: int = 3600):\n        import time\n\n        if not os.path.exists(DOWNLOAD_DIR):\n            return\n\n        now = time.time()\n        count = 0\n\n        for filename in os.listdir(DOWNLOAD_DIR):\n            filepath = os.path.join(DOWNLOAD_DIR, filename)\n            try:\n                if os.path.isfile(filepath):\n                    file_age = now - os.path.getmtime(filepath)\n                    if file_age > max_age_seconds:\n                        os.remove(filepath)\n                        count += 1\n            except Exception as e:\n                logger.warning(f\"\"Failed to clean {filepath}: {e}\"\")\n\n        if count > 0:\n            logger.info(f\"\"Cleaned up {count} old files from {DOWNLOAD_DIR}\"\")\n''''''\n\nfilepath = r''C:\\Users\\maliu\\OneDrive\\Desktop\\Projects\\Telegram Bots\\nexus_project\\bot_net\\bots\\downloader_bot\\services\\downloader.py''\nwith open(filepath, ''w'', encoding=''utf-8'') as f:\n    f.write(content)\nprint(''File written successfully'')\n\")",
      "Bash(git commit -m \"$(cat <<''EOF''\nfeat: Move frontend to Vercel deployment\n\n- Add vercel.json configuration for Vite build\n- Add .env.production with production API URL\n- Update CORS origins to include Vercel domain\n- Disable frontend container in docker-compose (moved to Vercel)\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\")",
      "Bash(git push)",
      "Bash(git commit -m \"$(cat <<''EOF''\nfix: Update nginx config for Vercel frontend\n\n- Remove frontend upstream (moved to Vercel)\n- Add redirects from admin.shadow-api.ru to Vercel\n- Keep API proxy working on api.shadow-api.ru\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\")",
      "Bash(git commit -m \"$(cat <<''EOF''\nfix: Enable HTTPS for API and fix CORS\n\n- Add SSL configuration to nginx for api.shadow-api.ru\n- Update CORS_ORIGINS in docker-compose to include Vercel domain\n- HTTP to HTTPS redirect for API subdomain\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\")",
      "Bash(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@185.96.80.254 \"echo ''Connected!'' && uname -a && free -h && df -h /\")",
      "Bash(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@66.151.33.167 \"echo ''Connected to Hostkey!'' && uname -a && free -h\")",
      "Bash(ssh:*)",
      "Bash(nslookup:*)",
      "Bash(scp:*)",
      "Bash(curl:*)",
      "Bash(git fetch:*)",
      "Bash(powershell -ExecutionPolicy Bypass -File deploy_vps.ps1)",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cd /root/nexus_project && git pull origin main\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"ls -la /root/\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cd /root/telegrambots && git pull origin main\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"rm -rf /root/telegrambots && git clone https://github.com/Malyugin777/telegrambots.git /root/telegrambots\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"ls -la /root/telegrambots/\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cat /root/telegrambots/infrastructure/.env 2>/dev/null || echo ''NO ENV FILE''\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"find /root -name ''.env'' -o -name ''*.env'' 2>/dev/null | head -5\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"docker ps -a\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"docker exec nexus_bot_manager env | grep -E ''BOT_TOKEN|POSTGRES|REDIS|JWT''\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cat > /root/telegrambots/infrastructure/.env << ''EOF''\n# Database\nPOSTGRES_USER=nexus\nPOSTGRES_PASSWORD=nexus_secure_pwd_2024\nPOSTGRES_DB=nexus_db\nPOSTGRES_HOST=postgres\nPOSTGRES_PORT=5432\n\n# Redis\nREDIS_HOST=redis\nREDIS_PORT=6379\n\n# Downloader Bot (SaveNinja)\nDOWNLOADER_BOT_TOKEN=8222846501:AAE6lJ5xBispWUBzVmCr7tKfKSI1NcSlHyI\nEOF\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cd /root/telegrambots/infrastructure && docker-compose down && docker-compose up -d --build\")",
      "Bash(ssh -o StrictHostKeyChecking=no root@66.151.33.167 \"cd /root/telegrambots/infrastructure && docker compose down && docker compose up -d --build\")",
      "Bash(curl -s https://api.shadow-api.ru/api/docs)",
      "Bash(npm install:*)",
      "Bash(npm run build)",
      "Bash(tree:*)",
      "Bash(git restore:*)",
      "Bash(git diff:*)"
    ]
  }
}
